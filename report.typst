#set text(lang: "en")
#set page("a4", margin: 1in)
#import "Report/lib.typ": project

#show: project.with(
  title: "Studtasks (nadhem) – Shared Academic Task Manager",
  authors: (
    "Abdulaziz Fahad BinAskar",
    "Saud Mishari Aldalbahy",
    "Naif Salman Aldrees",
    "Abdulaziz Mohammed Alkthiri",
  ),
  mentors: (
    "Dr. Imran Qureshi",
  ),
  branch: "College of Computer and Information Sciences (CCIS)",
  academic-year: "2025-2026",
  features: "fancy-codeblocks",
  footer-text: "IMSIU",
)


= Setup Instructions

== Prerequisites

- Elixir ~> 1.15 and Erlang/OTP (compatible)
- PostgreSQL (local instance for development)
- Docker and Docker Compose (for local DB in development)
== Local Development (Dev)

1. Install dependencies and set up the database:

```bash
mix setup
docker compose up -d db
```

2. Start the server:

```bash
mix phx.server
```

3. Visit http://localhost:4000

Notes:
- Emails are delivered to the local mailbox at /dev/mailbox in dev. Use it to complete email verification.


== Environment Configuration

The application uses the following environment variables (see `example.env` for reference):

=== Secrets (store in Secret Manager for production):

- `SECRET_KEY_BASE` - generate with `mix phx.gen.secret`
- `PGUSER` - PostgreSQL username
- `PGPASSWORD` - PostgreSQL password
- `PGDBNAME` - PostgreSQL database name
- `PGHOST` - PostgreSQL host (e.g., Neon endpoint)

=== Non-Secret Environment Variables:

- `PHX_HOST` - your domain (e.g., studtasks.example.com) we will use the one provided by cloud run
- `POOL_SIZE` - Ecto connection pool size (default: 10)
- `ECTO_IPV6` - enable IPv6 for Ecto if needed (true|1 enables)

=== Database Configuration:

- Production: PostgreSQL via Neon (serverless PostgreSQL)
  - Individual Postgres parameters (PGUSER, PGPASSWORD, PGDBNAME, PGHOST) are used to construct the database URL
  - All sensitive credentials stored in Google Secret Manager

- Development: PostgreSQL locally
  - Uses PGDEVHOST environment variable for local development
  - Requires a local PostgreSQL instance running

=== Mailer (Production):

- Configure Swoosh adapter in runtime for a real provider (Resend/Mailgun/SES)
- Set `config :swoosh, :api_client, Swoosh.ApiClient.Req`
- Store any provider credentials in Secret Manager and inject as env vars at deploy time

= Project Metadata

== Technology Stack

- Language & Runtime: Elixir, Erlang/OTP
- Web Framework: Phoenix 1.8 + LiveView 1.1
- Realtime: Phoenix PubSub + LiveView
- Database: PostgreSQL (Neon in production, local instance in development)
- Auth & Security: Argon2 (argon2_elixir), Phoenix/Plug sessions, email verification (Swoosh)
- Frontend: Tailwind CSS v4, DaisyUI components, Phoenix core components
- Containerization: Docker, Docker compose (for local dev DB), Docker Hub registry
- Deployment: Google Cloud Run
- CI/CD: GitHub Actions workflow for automated builds and deployments

== Application Features

=== Core Features (MVP)

- User Authentication
  - Registration and login with secure password hashing (Argon2)
  - Email verification on sign-up
- Task Management (CRUD)
  - Create tasks with: title (required), description, due date, priority (Low/Medium/High)
  - Assignment to self or other course members
  - Read: list with filtering (status, assignee, priority) and sorting (e.g., due date)
  - Update: edit details, mark complete/incomplete
  - Delete tasks

// to avoid splitting sections awkwardly
#pagebreak()
- Real-time Synchronization
  - All task operations are reflected live across connected clients via LiveView/PubSub
  - Data model aligns with Users → Courses → Tasks
- Frontend UI
  - Clean login/register pages
  - Dashboard: overview of a user’s tasks across all courses
  - Course view: tasks for a specific course/group only
  - Forms for creating/editing tasks using Phoenix `<.form>` / `<.input>` components
  - Clear completed vs pending indicators with Tailwind/DaisyUI styles

=== Implemented Bonus Features
- Multi-language support (i18n) with English and Arabic locales
- Forgot password (reset flow via email)
- Data Visualization
- Drag-and-drop task ordering (kanban)

= Project Architecture
== Current Architecture

- Elixir/Phoenix + LiveView
- PostgreSQL for all environments (Neon serverless in production, local instance for development)
- Google Cloud Run (fully managed container runtime with autoscaling and scale-to-zero)
// #image(image("/Report/Architecture/CurrentArchitecture.png", width: 100%), caption: [Current Application Architecture])

=== Why This Architecture?

- Elixir/Phoenix:
  - Excellent concurrency and fault tolerance
  - LiveView for first-class realtime UX without heavy client JS
  - Built-in Pub/Sub for efficient live synchronization

- Neon (PostgreSQL):
  - Serverless, globally distributed PostgreSQL with low-latency edge access
  - Managed operations with simple connection model (DATABASE_URL + token)
  - Generous free tier

- Google Cloud Run:
  - Fully managed container runtime (no servers or Kubernetes to manage)
  - Scales to zero when idle; fast scale-out on demand
  - Simple deploys from Artifact Registry with health checks, autoscaling, and request concurrency controls
  - Custom domains and TLS via Cloud Run's managed certificates
  - Generous free tier

=== Diagram (High-Level)

- Browser (LiveView) ⇄ LiveView ⇄ DB
  - Production: Neon (serverless PostgreSQL over network)
  - Development: Local PostgreSQL instance
- Live updates flow through PubSub; forms/components use Phoenix core components
// #image(image("/Report/Architecture/ArchetictureDiagram.png", width: 100%), caption: [Application Architecture Diagram])

== Other Proposed Architectures

=== Stack 1 (Containerized, FE/BE split)

- Docker, Redis, Node.js/Express, PostgreSQL, React
// #image(image("/Report/Architecture/Stack1.png", width: 100%), caption: [Proposed Stack 1 Architecture])

=== Stack 2 (Serverless-leaning)

- Firebase, Next.js, Vercel
// #image(image("/Report/Architecture/Stack2.png", width: 100%), caption: [Proposed Stack 2 Architecture])

=== Stack 3 (Clustered Elixir)
- Elixir/Phoenix Kubernetes, PostgreSQL
// #image(image("/Report/Architecture/Stack3.png", width: 100%), caption: [Proposed Stack 3 Architecture])
=== Why Not These for MVP?

- Stack 1: Adds operational complexity (Redis, Docker, FE/BE split) with less out-of-the-box realtime ergonomics vs Phoenix LiveView.
- Stack 2: Great serverless velocity, but less control/customization and tight coupling to vendor services compared to a cloud-agnostic Phoenix stack.
- Stack 3: More Expensive than Cloud run with little benifet for this MVP. We Would have used it if it had the same cost as cloud run.

== Screenshots

Our application features a clean and intuitive user interface designed for ease of use and efficiency. Below are some screenshots showcasing key pages of the application:

#figure(image("/Report/Screens/Homepage.png", width: 100%), caption: [The Nadhem Homepage])
#figure(image("/Report/Screens/Homepage-AR.png", width: 100%), caption: [The Nadhem Homepage in Arabic])

#figure(image("/Report/Screens/dashboard.png", width: 100%), caption: [User Dashboard overview])
#figure(image("/Report/Screens/tasks.png", width: 100%), caption: [Course/group Kanban task view])
#figure(image("/Report/Screens/tasks-ListView.png", width: 100%), caption: [Course/group List task view])
#figure(image("/Report/Screens/login.png", width: 100%), caption: [Login page])
#figure(image("/Report/Screens/register.png", width: 100%), caption: [Register page])
#figure(image("/Report/Screens/AccountSettings.png", width: 100%), caption: [Account settings Page])




= Deployment & Demo

- URL: #link("https://studtasks-run-container-1043330219835.europe-west3.run.app")[Application] (deployed via GitHub Actions to Google Cloud Run)

== Deployment

=== Automated Deployment via GitHub Actions

The application uses a GitHub Actions workflow (`.github/workflows/deploy.yml`) for continuous deployment to Google Cloud Run on every push to the `main` branch.

==== Workflow Overview:

1. *Build Phase*:
  - Checks out the code
  - Sets up Docker Buildx for efficient multi-platform builds
  - Logs in to Docker Hub using secrets
  - Builds and pushes the Docker image with multiple tags (SHA, main, latest)
  - Uses GitHub Actions cache and Docker Hub registry cache for faster builds

2. *Deploy Phase*:
  - Authenticates to Google Cloud using Workload Identity Federation (no service account keys needed)
  - Deploys the container image to Cloud Run in the `europe-west3` region
  - Configures environment variables and secrets from Google Secret Manager

==== Required GitHub Secrets:

- `DOCKERHUB_USERNAME` - Docker Hub username
- `DOCKERHUB_TOKEN` - Docker Hub access token
- `GCP_WORKLOAD_IDENTITY_PROVIDER` - Google Cloud Workload Identity Provider ID
- `GCP_SERVICE_ACCOUNT_EMAIL` - Service account email for deployment

==== Required GitHub Variables:

- `GCP_REGION` - Google Cloud region (default: europe-west3)
- `SERVICE_NAME` - Cloud Run service name (default: studtasks-service)
- `PHX_HOST` - Application domain (default: studtasks.askardesign.com)

==== Required Google Secret Manager Secrets:

- `SECRET_KEY_BASE` - Phoenix secret key base
- `PGDBNAME` - PostgreSQL database name
- `PGUSER` - PostgreSQL username
- `PGPASSWORD` - PostgreSQL password
- `PGHOST` - PostgreSQL host (Neon endpoint)

==== Deployment Configuration:

- Region: europe-west3
- Min instances: 0 (scale-to-zero when idle)
- Max instances: 5
- Pool size: 10 database connections
- Platform: managed (fully managed Cloud Run)
- Authentication: allow unauthenticated (public access) Auth is handled by the application

=== Quick Deploy Notes - Google Cloud Run + Neon

High-level checklist:

+ *Container Image*:
  - GitHub Actions automatically builds and pushes to Docker Hub on every commit to `main`
  - Image tags: `<SHA>`, `main`, `latest`
  - Uses layer caching for faster builds

+ *Environment & Secrets*:
  - Use Google Secret Manager for all sensitive values (see Required Secrets above)
  - Non-sensitive env vars configured in the workflow (PHX_HOST, PHX_SERVER, POOL_SIZE)
  - Cloud Run automatically sets `PORT`; Phoenix listens on it

+ *Cloud Run Service*:
  - Automatically deployed via GitHub Actions workflow
  - Health check path: `/`
  - Autoscaling: 0-5 instances with 80 concurrent requests per container

+ *Observability & Ops*:
  - Logs/metrics stream to Cloud Logging and Cloud Monitoring
  - Monitor deployment status in GitHub Actions workflow runs

Notes:
- App is stateless; persistence is in Neon PostgreSQL
- Workload Identity Federation provides secure authentication without service account keys
- Docker Hub registry cache and GitHub Actions cache significantly speed up builds

=== Manual Deployment (Alternative)

If you need to deploy manually instead of using the GitHub Actions workflow:
```bash
# Build & push to Docker Hub
IMAGE="docker.io/abo3skr/studtasks:$(git rev-parse --short HEAD)"
docker build -t "$IMAGE" .
docker push "$IMAGE"

# Deploy to Cloud Run using the Docker Hub image
gcloud run deploy studtasks-service \
  --image "$IMAGE" \
  --region europe-west3 \
  --platform managed \
  --allow-unauthenticated \
  --set-env-vars PHX_HOST=studtasks.askardesign.com,PHX_SERVER=true \
  --set-env-vars POOL_SIZE=10 \
  --set-secrets \
    SECRET_KEY_BASE=SECRET_KEY_BASE:latest \
    PGDBNAME=PGDBNAME:latest \
    PGUSER=PGUSER:latest \
    PGPASSWORD=PGPASSWORD:latest \
    PGHOST=PGHOST:latest \
  --min-instances=0 \
  --max-instances=5
```

= Conclusion

Studtasks (nadhem) has been successfully developed as a fully functional shared academic task manager, demonstrating the power of modern web technologies in creating real-time collaborative applications. The project achieved all core MVP features including user authentication, comprehensive task management with CRUD operations, and real-time synchronization across multiple users.

== What We Learned

Throughout this project, our team gained valuable experience across multiple domains:

=== Technical Skills:
- Mastered Elixir/Phoenix framework and its real-time capabilities through Phoenix LiveView
- Learned the intricacies of building stateful, real-time applications without heavy JavaScript frameworks
- Gained hands-on experience with modern deployment practices using containerization (Docker) and serverless infrastructure (Google Cloud Run)
- Implemented secure authentication patterns using Argon2 and email verification flows

=== DevOps & Cloud Computing:
- Set up automated CI/CD pipelines using GitHub Actions for continuous deployment
- Learned to work with Google Cloud Platform services including Cloud Run, Secret Manager, and Workload Identity Federation
- Implemented production-grade infrastructure with autoscaling, health checks, and zero-downtime deployments
- Managed secrets and environment configuration across development and production environments

=== Software Architecture:
- Evaluated multiple technology stacks and made informed architectural decisions
- Balanced trade-offs between development velocity, operational complexity, and feature requirements
- Implemented separation of concerns through proper Phoenix context boundaries
- Designed scalable database schemas with proper relationships and constraints

== Overall Experience

The development of Studtasks was both challenging and rewarding. Starting with a clear vision for an academic task manager, we navigated through various technical decisions and implementation challenges to deliver a polished, production-ready application.

The choice of Phoenix LiveView proved excellent for our use case, providing real-time synchronization with minimal client-side complexity. The learning curve for Elixir was steep initially, but the framework's conventions and excellent documentation made it manageable. We particularly appreciated how LiveView's pub/sub architecture elegantly solved the real-time collaboration requirements without requiring complex WebSocket management.

Deploying to Google Cloud Run taught us about modern serverless architectures and the benefits of managed infrastructure. The scale-to-zero capability and automatic scaling gave us confidence that the application could handle varying loads efficiently while minimizing costs during low-traffic periods.

Implementing internationalization (i18n) for English and Arabic was particularly meaningful, as it made the application accessible to a broader user base and demonstrated our commitment to inclusivity. The forgot password feature and data visualization capabilities added polish beyond the MVP requirements.

The project reinforced the importance of proper planning, clear documentation, and automated testing. Our investment in GitHub Actions CI/CD pipeline paid dividends by enabling rapid iteration and confident deployments throughout the development cycle.

== Future Work

Whilst the current Application is fully functional, several Features could further improve the UX of the application:

- Push Notifications for assigned tasks or upcoming deadlines
- Comments/Discussion thread on individual tasks
- Integration with external calendar services (e.g., Google Calendar)
- File attachments for tasks (e.g., upload PDFs, images)
- Offline support with local caching and sync when online using Service Workers
- more Data Visualization
  - Advanced analytics and productivity insights
  - Team performance metrics and reporting

== Final Thoughts

The project has prepared us for real-world software development by exposing us to production-grade tools, deployment strategies, and architectural patterns. We are proud of what we accomplished and confident that the skills and knowledge gained will serve us well in our future careers.
