
= Studtasks (nadhm) – Shared Academic Task Manager

== Project Title & Description

- Title: nadhm (Studtasks)
- Description: A course-centric, real-time task manager for student groups. Each course/group has a shared task list where members can add, assign, complete, and discuss tasks tied to homework, projects, and exams. Live synchronization keeps everyone on the same page without manual refreshes.

== Team Members

- Abdulaziz Fahad BinAskar
- Saud Mishari AlOtaibi?
- Naif
== Setup Instructions

=== Prerequisites

- Elixir ~> 1.15 and Erlang/OTP (compatible)
- SQLite (bundled via ecto_sqlite3; no external server needed)
- A modern browser (Chrome/Firefox/Safari/Edge)

=== Local Development (Dev)

1. Install dependencies and set up the database:

```bash
mix setup
```

2. Start the server:

```bash
mix phx.server
```

3. Visit http://localhost:4000

Notes:
- Emails are delivered to the local mailbox at /dev/mailbox in dev. Use it to complete email verification.
- Assets (Tailwind v4, esbuild) are automatically installed and watched in dev.

=== Running Tests

```bash
mix test
```

=== Production (Overview)

Secrets and environment (prod):

- SECRET_KEY_BASE — store in Secret Manager; generate with `mix phx.gen.secret`
- DATABASE_URL — store in Secret Manager (Neon connection URL)
- PHX_HOST — your domain (e.g., nadhm.example.com) [env var]
- PORT — default 4000 [Cloud Run provides]
- POOL_SIZE — optional [env var]

Database (choose one):

- Neon (recommended for prod)
  - DATABASE_URL — Secret Manager secret with your Neon URL

- File-backed SQLite (simple single-node alternative)
  - DATABASE_PATH — absolute path to the SQLite file (e.g., `/etc/studtasks/studtasks.db`)
  - Note: Not suitable for Google Cloud Run (containers are stateless/ephemeral). Use Neon for Cloud Run.

Mailer (prod):

- Configure Swoosh adapter in runtime for a real provider (Resend/Mailgun/SES). Also set `config :swoosh, :api_client, Swoosh.ApiClient.Req`.
- Store any provider credentials (e.g., RESEND_API_KEY, MAILGUN_API_KEY, MAILGUN_DOMAIN, AWS credentials) in Secret Manager and inject them as env vars at deploy time.

Start with releases (illustrative):
```sh
```

== Technology Stack

- Language & Runtime: Elixir, Erlang/OTP
- Web Framework: Phoenix 1.8 + LiveView 1.1
- Realtime: Phoenix PubSub + LiveView
- Database: Neon (PostgreSQL) in production; SQLite (ecto_sqlite3) in development
- Auth & Security: Argon2 (argon2_elixir), Phoenix/Plug sessions, email verification (Swoosh)
- Email: Swoosh (dev: Local adapter at /dev/mailbox; prod: configure provider), delivered via Req client
- HTTP Client: Req (preferred)
- Frontend: Tailwind CSS v4, DaisyUI components, Phoenix core components
- Build Tooling: esbuild, Tailwind (via Mix tasks)
- Server Adapter: Bandit
- I18n: Gettext
  - Deployment: Google Cloud Run (managed containers, scale-to-zero); containerized (OCI/Docker)

== Application Features

=== Core Features (MVP)

- User Authentication
  - Registration and login with secure password hashing (Argon2)
  - Email verification on sign-up (Swoosh Local in dev)
  - Forgot password (reset flow via email)
- Task Management (CRUD)
  - Create tasks with: title (required), description, due date, priority (Low/Medium/High)
  - Assignment to self or other course members
  - Read: list with filtering (status, assignee, priority) and sorting (e.g., due date)
  - Update: edit details, mark complete/incomplete
  - Delete tasks
- Real-time Synchronization
  - All task operations are reflected live across connected clients via LiveView/PubSub
  - Data model aligns with Users → Courses → Tasks
- Frontend UI
  - Clean login/register pages
  - Dashboard: overview of a user’s tasks across all courses
  - Course view: tasks for a specific course/group only
  - Forms for creating/editing tasks using Phoenix `<.form>` / `<.input>` components
  - Clear completed vs pending indicators with Tailwind/DaisyUI styles
  - Drag-and-drop task ordering (kanban)

== Project Architecture
=== Current Architecture

- Elixir/Phoenix + LiveView
- Neon (PostgreSQL) for production data, SQLite file-backed for local dev
- Google Cloud Run (fully managed container runtime with autoscaling and scale-to-zero)

==== Why This Architecture?

- Elixir/Phoenix:
  - Excellent concurrency and fault tolerance
  - LiveView for first-class realtime UX without heavy client JS
  - Built-in Pub/Sub for efficient live synchronization
  - Local dev parity via plain SQLite

- Neon (PostgreSQL):
  - Serverless, globally distributed PostgreSQL with low-latency edge access
  - Managed operations with simple connection model (DATABASE_URL + token)

- Google Cloud Run:
  - Fully managed container runtime—no servers or Kubernetes to manage
  - Scales to zero when idle; fast scale-out on demand
  - Simple deploys from Artifact Registry with health checks, autoscaling, and request concurrency controls
  - Custom domains and TLS via Cloud Run's managed certificates

==== Diagram (High-Level)

- Browser (LiveView) ⇄ StudtasksWeb.Endpoint ⇄ Ecto (Repo) ⇄ Neon (PostgreSQL over network)
- Live updates flow through PubSub; forms/components use Phoenix core components
- In dev: Ecto (Repo) ⇄ local SQLite file for simplicity

=== Other Proposed Architectures

==== Stack 1 (Containerized, FE/BE split)

- Docker, Redis, Node.js/Express, SQLite, React

==== Stack 2 (Serverless-leaning)

- Firebase, Next.js, Vercel

==== Why Not These for MVP?

- Stack 1: Adds operational complexity (Redis, Docker, FE/BE split) with less out-of-the-box realtime ergonomics vs Phoenix LiveView.
- Stack 2: Great serverless velocity, but less control/customization and tight coupling to vendor services compared to a cloud-agnostic Phoenix stack.

== Screenshots


// Uncomment the following lines after adding images under /screens/
// #figure(image("/screens/login.png", width: 100%), caption: [Login page])
// #figure(image("/screens/dashboard.png", width: 100%), caption: [Dashboard overview])
// #figure(image("/screens/tasks.png", width: 100%), caption: [Course/group task view])

== Live Demo

- URL: TODO — Add deployed URL here (e.g., https://nadhm.example.com)

=== Quick Deploy Notes — Google Cloud Run + Neon

High-level checklist:

1) Container image
- Build a release image (e.g., `mix gen.release --docker`) and push to Google Artifact Registry.

2) Environment & Secrets
- Use Secret Manager for all sensitive values: `SECRET_KEY_BASE`, `DATABASE_URL`, and any mailer API keys.
- Non-sensitive env vars: `PHX_HOST`, `POOL_SIZE` (optional). Cloud Run sets `PORT` automatically.
- Ensure `PHX_SERVER=true` so the release boots the web endpoint.
- Cloud Run sets `PORT`; Phoenix must listen on it (supported by default when `PORT` is present).

3) Cloud Run Service
- Deploy a Cloud Run service from the Artifact Registry image; select region and CPU/RAM.
- Configure health check path (e.g., `/`) and container port.
- Autoscaling: set min instances to 0 (scale-to-zero) or 1 for warm start; set max instances and request concurrency.

4) Domain & TLS
- Map a custom domain in Cloud Run; TLS is automatic via Google-managed certificates.

5) Observability & Ops
- Logs/metrics stream to Cloud Logging and Cloud Monitoring; add alerting policies and dashboards.

Notes:
- App is stateless; persistence is in Neon. No volumes required.
- For local dev and CI, use SQLite; for Cloud Run production, use Neon.


=== Example deploy with gcloud

Illustrative commands (replace placeholders: `PROJECT_ID`, `REGION`, `REPO`, `SERVICE_NAME`, `YOUR_DOMAIN`). Assumes you created Secret Manager secrets `SECRET_KEY_BASE` and `DATABASE_URL` and granted the service account `roles/secretmanager.secretAccessor`:

```bash
# Build & push to Google Artifact Registry
IMAGE="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/studtasks:$(git rev-parse --short HEAD)"
gcloud builds submit --tag "$IMAGE" --project "$PROJECT_ID"

# Deploy to Cloud Run
gcloud run deploy ${SERVICE_NAME} \
  --image "$IMAGE" \
  --region "$REGION" \
  --platform managed \
  --allow-unauthenticated \
  --set-env-vars PHX_HOST=${YOUR_DOMAIN},PHX_SERVER=true \
  --set-env-vars POOL_SIZE=10 \
  --set-secrets SECRET_KEY_BASE=SECRET_KEY_BASE:latest,DATABASE_URL=DATABASE_URL:latest \
  --min-instances=0 --max-instances=5 \
  --concurrency=80
```

Tip: Before deploying, create the secrets and grant access to the Cloud Run runtime service account:

```bash
# Create secrets
gcloud secrets create SECRET_KEY_BASE --replication-policy=automatic
gcloud secrets create DATABASE_URL --replication-policy=automatic

# Add secret versions (paste your generated values)
echo -n "$(mix phx.gen.secret)" | gcloud secrets versions add SECRET_KEY_BASE --data-file=-
echo -n "postgres://<user>:<pass>@<host>:<port>/<db>" | gcloud secrets versions add DATABASE_URL --data-file=-

# Grant access (replace with your service account email)
gcloud secrets add-iam-policy-binding SECRET_KEY_BASE \
  --member=serviceAccount:<SERVICE_ACCOUNT_EMAIL> \
  --role=roles/secretmanager.secretAccessor
gcloud secrets add-iam-policy-binding DATABASE_URL \
  --member=serviceAccount:<SERVICE_ACCOUNT_EMAIL> \
  --role=roles/secretmanager.secretAccessor
```
