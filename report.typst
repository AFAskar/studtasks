
= Studtasks (nadhm) – Shared Academic Task Manager

== Project Title & Description

- Title: nadhm (Studtasks)
- Description: A course-centric, real-time task manager for student groups. Each course/group has a shared task list where members can add, assign, complete, and discuss tasks tied to homework, projects, and exams. Live synchronization keeps everyone on the same page without manual refreshes.

== Team Members

- TODO: Add full names and roles here
  - Abdulaziz Fahad BinAskar
  - Saud mishari
  - Naif

== Setup Instructions

=== Prerequisites

- Elixir ~> 1.15 and Erlang/OTP (compatible)
- SQLite (bundled via ecto_sqlite3; no external server needed)
- A modern browser (Chrome/Firefox/Safari/Edge)

=== Local Development (Dev)

1. Install dependencies and set up the database:

```bash
mix setup
```

2. Start the server:

```bash
mix phx.server
```

3. Visit http://localhost:4000

Notes:
- Emails are delivered to the local mailbox at /dev/mailbox in dev. Use it to complete email verification.
- Assets (Tailwind v4, esbuild) are automatically installed and watched in dev.

=== Running Tests

```bash
mix test
```

=== Production (Overview)

Environment variables (required):

- SECRET_KEY_BASE — generate with: `mix phx.gen.secret`
- PHX_HOST — your domain (e.g., nadhm.example.com)
- PORT — default 4000

Database (choose one):

- Turso (recommended for prod)
  - DATABASE_URL — libsql URL (e.g., `libsql://org-db.turso.io`)
  - TURSO_AUTH_TOKEN — auth token for the database
  - POOL_SIZE — e.g., 10–20

- File-backed SQLite (simple single-node alternative)
  - DATABASE_PATH — absolute path to the SQLite file (e.g., `/etc/studtasks/studtasks.db`)

Mailer (prod):

- Configure Swoosh adapter in runtime for a real provider (Resend/Mailgun/SES). Also set `config :swoosh, :api_client, Swoosh.ApiClient.Req`.

Start with releases (illustrative):

```bash
MIX_ENV=prod mix release
PHX_SERVER=true SECRET_KEY_BASE=... PHX_HOST=nadhm.example.com PORT=4000 \
DATABASE_URL=libsql://org-db.turso.io TURSO_AUTH_TOKEN=... POOL_SIZE=15 \
_build/prod/rel/studtasks/bin/studtasks start
```

== Technology Stack

- Language & Runtime: Elixir, Erlang/OTP
- Web Framework: Phoenix 1.8 + LiveView 1.1
- Realtime: Phoenix PubSub + LiveView
- Database: Turso (libSQL) in production; SQLite (ecto_sqlite3) in development
- Auth & Security: Argon2 (argon2_elixir), Phoenix/Plug sessions, email verification (Swoosh)
- Email: Swoosh (dev: Local adapter at /dev/mailbox; prod: configure provider), delivered via Req client
- HTTP Client: Req (preferred)
- Frontend: Tailwind CSS v4, DaisyUI components, Phoenix core components
- Build Tooling: esbuild, Tailwind (via Mix tasks)
- Server Adapter: Bandit
- I18n: Gettext
  - Deployment: AWS EKS (Kubernetes); containerized (OCI/Docker)

== Application Features

=== Core Features (MVP)

- User Authentication
  - Registration and login with secure password hashing (Argon2)
  - Email verification on sign-up (Swoosh Local in dev)
  - Forgot password (reset flow via email)
- Task Management (CRUD)
  - Create tasks with: title (required), description, due date, priority (Low/Medium/High)
  - Assignment to self or other course members
  - Read: list with filtering (status, assignee, priority) and sorting (e.g., due date)
  - Update: edit details, mark complete/incomplete
  - Delete tasks
- Real-time Synchronization
  - All task operations are reflected live across connected clients via LiveView/PubSub
  - Data model aligns with Users → Courses → Tasks
- Frontend UI
  - Clean login/register pages
  - Dashboard: overview of a user’s tasks across all courses
  - Course view: tasks for a specific course/group only
  - Forms for creating/editing tasks using Phoenix `<.form>` / `<.input>` components
  - Clear completed vs pending indicators with Tailwind/DaisyUI styles
  - Drag-and-drop task ordering (kanban)

== Project Architecture
=== Current Architecture

- Elixir/Phoenix + LiveView
- Turso (libSQL distributed SQLite) for production data, SQLite file-backed for local dev
- Kubernetes (AWS EKS)

==== Why This Architecture?

- Elixir/Phoenix:
  - Excellent concurrency and fault tolerance
  - LiveView for first-class realtime UX without heavy client JS
  - Built-in Pub/Sub for efficient live synchronization
- Turso (libSQL):
  - Serverless, globally distributed SQLite with low-latency edge access
  - Managed operations with simple connection model (DATABASE_URL + token)
  - Local dev parity via plain SQLite
- Kubernetes (EKS):
  - Cloud-agnostic orchestration with autoscaling, rollouts, and resilience on AWS
  - Clear separation of stateless app vs managed DB (Turso)

==== Diagram (High-Level)

- Browser (LiveView) ⇄ StudtasksWeb.Endpoint ⇄ Ecto (Repo) ⇄ Turso (libSQL over network)
- Live updates flow through PubSub; forms/components use Phoenix core components
- In dev: Ecto (Repo) ⇄ local SQLite file for simplicity

=== Other Proposed Architectures

==== Stack 1 (Containerized, FE/BE split)

- Docker, Redis, Node.js/Express, SQLite, React

==== Stack 2 (Serverless-leaning)

- Firebase, Next.js, Vercel

==== Why Not These for MVP?

- Stack 1: Adds operational complexity (Redis, Docker, FE/BE split) with less out-of-the-box realtime ergonomics vs Phoenix LiveView.
- Stack 2: Great serverless velocity, but less control/customization and tight coupling to vendor services compared to a cloud-agnostic Phoenix stack.

== Screenshots


// Uncomment the following lines after adding images under /screens/
// #figure(image("/screens/login.png", width: 100%), caption: [Login page])
// #figure(image("/screens/dashboard.png", width: 100%), caption: [Dashboard overview])
// #figure(image("/screens/tasks.png", width: 100%), caption: [Course/group task view])

== Live Demo

- URL: TODO — Add deployed URL here (e.g., https://nadhm.example.com)

=== Quick Deploy Notes — AWS EKS + Turso

High-level checklist:

1) Container image
- Build a minimal release image (OCI/Docker) and push to Amazon ECR.

2) Secrets & Config
- Kubernetes Secret: `SECRET_KEY_BASE`, `TURSO_AUTH_TOKEN` (and email provider creds if any)
- ConfigMap or env: `DATABASE_URL` (Turso libsql URL), `PHX_HOST`, `PORT`, `POOL_SIZE`

3) Deployment & Service
- Deployment: set `PHX_SERVER=true` and env from Secret/ConfigMap; add readiness/liveness probes
- Service: ClusterIP for internal, or LoadBalancer/Ingress for external access

4) Ingress & TLS
- Use AWS Load Balancer Controller + Ingress; terminate TLS with ACM certificate

5) Autoscaling & Ops
- Configure HPA (CPU/Memory), resource requests/limits, rolling updates
- Centralized logs/metrics (e.g., CloudWatch), alerts

Notes:
- App is stateless; all persistence is handled by Turso. No PVC required.
- For local dev and CI, you can run on a file-backed SQLite and switch to Turso in prod via env vars.
